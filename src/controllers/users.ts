import { Request, Response } from 'express';
import { collections } from '../database';
import { User } from '../models/user';
import { ObjectId } from 'mongodb';
import bcrypt from 'bcrypt';
import crypto from 'crypto';
import EmailService from '../services/emailService';

export const loginUser = async (req: Request, res: Response) => {
  // Login user with email and password
  
  const { email, password } = req.body;
  
  if (!email || !password) {
    return res.status(400).json({ error: "Email and password are required" });
  }
  
  try {
    // Check database connection first
    if (!collections.users) {
      console.error('‚ùå Login attempt failed - Database not connected');
      return res.status(500).json({ 
        error: "Database connection error",
        message: "Cannot authenticate - database is not available"
      });
    }
    
    // Find user by email
    const user = await collections.users.findOne({ email: email.toLowerCase().trim() }) as unknown as User;
    
    if (!user) {
      console.log(`‚ö†Ô∏è Login attempt failed - User not found: ${email}`);
      return res.status(401).json({ error: "Invalid credentials" });
    }
    
    // Validate that user has a password hash
    if (!user.password || typeof user.password !== 'string' || user.password.trim() === '') {
      console.error(`‚ùå Login attempt failed - User has no password hash: ${email}`);
      return res.status(500).json({ 
        error: "Account configuration error",
        message: "User account is not properly configured"
      });
    }
    
    // CRITICAL: Validate password hash format (bcrypt hashes start with $2a$, $2b$, or $2y$)
    if (!user.password.startsWith('$2') || user.password.length !== 60) {
      console.error(`‚ùå Invalid password hash format for: ${email}`);
      return res.status(500).json({ 
        error: "Account configuration error",
        message: "User account password is not properly configured. Please contact support."
      });
    }
    
    // CRITICAL: Ensure password hash is not plain text
    if (user.password === password) {
      console.error(`‚ùå Security breach: Password stored in plain text for: ${email}`);
      return res.status(500).json({ 
        error: "Security error",
        message: "Password security issue detected. Please contact support."
      });
    }
    
    // Check if user is banned
    if (user.isBanned) {
      console.log(`‚ö†Ô∏è Login attempt blocked - User is banned: ${email}`);
      return res.status(403).json({ error: "Your account has been banned and you cannot access the system" });
    }
    
    // CRITICAL SECURITY: Password validation - ABSOLUTE BLOCK ON FAILURE
    // CRITICAL: Initialize as false - MUST be explicitly set to true
    let isPasswordValid: boolean = false;
    
    try {
      // SECURITY: bcrypt.compare is the ONLY way to verify password
      // It returns false if password doesn't match, true only if it matches exactly
      const comparisonResult = await bcrypt.compare(password, user.password);
      
      // SECURITY: Only accept if result is EXPLICITLY true (boolean true)
      if (comparisonResult === true && typeof comparisonResult === 'boolean') {
        isPasswordValid = true;
      } else {
        isPasswordValid = false;
      }
    } catch (bcryptError) {
      // CRITICAL: Any error in bcrypt comparison means authentication FAILS
      console.error(`‚ùå Password comparison ERROR for ${email}:`, bcryptError);
      isPasswordValid = false;
      return res.status(500).json({ 
        error: "Authentication error",
        message: "Password verification failed due to account configuration issue"
      });
    }
    
    // CRITICAL SECURITY CHECK: Must be explicitly true
    if (!isPasswordValid || isPasswordValid !== true) {
      console.log(`‚ùå Login rejected - Invalid password for: ${email}`);
      return res.status(401).json({ 
        error: "Invalid credentials",
        message: "Email or password is incorrect"
      });
    }
    
    // Additional type safety check
    if (typeof isPasswordValid !== 'boolean') {
      console.error(`‚ùå Security error - Password validation type mismatch`);
      return res.status(500).json({ 
        error: "Authentication error",
        message: "Password verification failed"
      });
    }
    
    // Return user info (without password) - NO TOKEN GENERATED HERE
    const { password: _, ...userWithoutPassword } = user;
    
    // Send login response
    res.status(200).json({
      message: "Login successful",
      user: userWithoutPassword
      // NOTE: No token is generated by this backend - tokens must come from frontend or another service
    });
    
  } catch (error) {
    if (error instanceof Error) {
      console.log(`Login error: ${error.message}`);
    }
    res.status(500).json({ error: "Login failed" });
  }
};

export const getUsers = async (req: Request, res: Response) => {

    const rawFilter = req.query.filter;
    let filterObj = {};

    if (typeof rawFilter === 'string') {
      try {
        filterObj = JSON.parse(rawFilter);
      } catch (err) {
        console.error("Invalid filter JSON:", err);
        return res.status(400).json({ error: "Invalid filter format" });
      }
    }

  try {
    if (!collections.users) {
      console.error('‚ùå Database collections not initialized - users collection is undefined');
      console.log('üîç Collections status:', {
        users: !!collections.users,
        appointments: !!collections.appointments,
        blockedDates: !!collections.blockedDates
      });
      return res.status(500).json({ 
        error: 'Database not connected',
        details: 'Collections not initialized - check database connection'
      });
    }
    const users = await collections.users.find(filterObj).toArray();
    res.json(users);
  } catch (error) {
    if (error instanceof Error) {
      console.error(`Issue with GET users: ${error.message}`);
      console.error('Stack trace:', error.stack);
    }
    res.status(500).json({ 
      error: 'get failed',
      details: error instanceof Error ? error.message : 'Unknown error'
    });
  }
};

export const getUserById = async (req: Request, res: Response) => {
  //get a single  user by ID from the database

  let id: string = req.params.id;
  try {
    const query = { _id: new ObjectId(id) };
    const user = (await collections.users?.findOne(query)) as unknown as User;

    if (user) {
      res.status(200).send(user);
    }
    else {
      res.status(404).send(`Unable to find matching document with id: ${req.params.id}`);
    }
  } catch (error) {

    if (error instanceof Error) {
      console.log('Issue with GET for user ${id}  ${error.message}')
    }
    res.status(404).send(`Unable to find matching document with id: ${req.params.id}`);
  }
};

export const createUser = async (req: Request, res: Response) => {
  // create a new user in the database - SECURE REGISTRATION

  // Check database connection first
  if (!collections.users) {
    console.error('‚ùå Database not connected - users collection unavailable');
    return res.status(500).json({ 
      error: 'Database not connected',
      message: 'Cannot create user - database connection failed'
    });
  }

  const { name, phonenumber, phone, email, password, dob, role } = req.body;
  
  // SECURITY: Validate required fields
  if (!name || !email || !password || (!phonenumber && !phone)) {
    return res.status(400).json({
      error: "Missing required fields",
      message: "Name, email, password, and phone number are required"
    });
  }

  // SECURITY: Normalize and validate email
  const normalizedEmail = email.toLowerCase().trim();
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  if (!normalizedEmail || !emailRegex.test(normalizedEmail)) {
    return res.status(400).json({
      error: "Invalid email format",
      message: "Please provide a valid email address"
    });
  }

  // SECURITY: Password validation
  if (!password || typeof password !== 'string' || password.length < 8 || password.length > 128) {
    return res.status(400).json({
      error: "Password too weak",
      message: "Password must be between 8 and 128 characters long"
    });
  }

  // SECURITY: Password complexity requirements
  const hasLowerCase = /[a-z]/.test(password);
  const hasUpperCase = /[A-Z]/.test(password);
  const hasNumber = /\d/.test(password);
  
  if (!hasLowerCase || !hasUpperCase || !hasNumber) {
    return res.status(400).json({
      error: "Password too weak",
      message: "Password must contain at least one lowercase letter, one uppercase letter, and one number"
    });
  }

  // SECURITY: Prevent common weak passwords
  const commonPasswords = ['password', 'password123', '12345678', 'admin123', 'qwerty123'];
  if (commonPasswords.includes(password.toLowerCase())) {
    return res.status(400).json({
      error: "Password too weak",
      message: "This password is too common. Please choose a stronger password"
    });
  }

  // SECURITY: Sanitize name input
  const sanitizedName = name.trim();
  if (!sanitizedName || sanitizedName.length === 0 || sanitizedName.length > 100) {
    return res.status(400).json({
      error: "Invalid name",
      message: "Name must be between 1 and 100 characters"
    });
  }

  // SECURITY: Prevent admin role assignment via registration
  const userRole = role === "admin" ? "user" : (role || "user");

  // SECURITY: Check if user already exists (case-insensitive)
  try {
    const existingUser = await collections.users.findOne({ 
      email: normalizedEmail 
    });
    if (existingUser) {
      return res.status(409).json({
        error: "User already exists",
        message: "An account with this email already exists"
      });
    }
  } catch (error) {
    console.error('‚ùå Error checking existing user:', error);
    return res.status(500).json({ error: "Internal server error" });
  }
  
  // SECURITY: Validate and sanitize phone number
  let phoneNumber = phonenumber || phone;
  const phoneRegex = /^08[3-9]\d{7,8}$/;
  
  if (!phoneNumber || !phoneRegex.test(phoneNumber)) {
    return res.status(400).json({
      error: "Invalid phone number",
      message: "Phone number must be a valid Irish mobile number (e.g., 0831234567)"
    });
  }
  
  // SECURITY: Hash the password with increased salt rounds
  const saltRounds = 12;
  let hashedPassword: string;
  try {
    hashedPassword = await bcrypt.hash(password, saltRounds);
    if (!hashedPassword || !hashedPassword.startsWith('$2')) {
      return res.status(500).json({ 
        error: "Password processing error",
        message: "Failed to securely process password"
      });
    }
  } catch (error) {
    console.error('‚ùå Error hashing password:', error);
    return res.status(500).json({ error: "Error processing password" });
  }
  
  // SECURITY: Create user object with sanitized values
  const newUser: User = {
    name: sanitizedName, 
    phonenumber: phoneNumber, 
    email: normalizedEmail, 
    password: hashedPassword,
    dob: dob ? new Date(dob) : undefined,
    role: userRole,
    dateJoined: new Date(), 
    lastUpdated: new Date(),
    isBanned: false
  }

  // SECURITY: Insert user into database
  try {
    const result = await collections.users.insertOne(newUser);

    if (!result || !result.insertedId) {
      return res.status(500).json({ 
        error: "Failed to create user",
        message: "Database operation failed"
      });
    }

    // Send welcome email in background (non-blocking)
    setImmediate(async () => {
      try {
        await EmailService.sendWelcomeEmail(newUser);
      } catch (emailError) {
        // Silently fail - email is non-critical
      }
    });

    // SECURITY: Return user info WITHOUT password
    const userResponse = {
      id: result.insertedId,
      name: newUser.name,
      email: newUser.email,
      phonenumber: newUser.phonenumber,
      role: newUser.role,
      dateJoined: newUser.dateJoined
    };

    res.status(201).location(`${result.insertedId}`).json({ 
      message: "User registered successfully",
      userId: result.insertedId,
      user: userResponse
    });
  }
  catch (error) {
    console.error('‚ùå Error creating user:', error);
    if (error instanceof Error) {
      // SECURITY: Handle duplicate key errors (race condition protection)
      if (error.message.includes('duplicate key') || error.message.includes('E11000')) {
        return res.status(409).json({
          error: "User already exists",
          message: "An account with this email already exists"
        });
      }
      res.status(500).json({ 
        error: "Failed to create user",
        message: "An error occurred during registration"
      });
    }
    else {
      res.status(500).json({ 
        error: "Failed to create user",
        message: "An unexpected error occurred"
      });
    }
  }
};


export const updateUser = async (req: Request, res: Response) => {

  const id: string = req.params.id;

  const { name, phonenumber, dob } = req.body
  
  // Set default phone number if not provided
  const phoneNumber = phonenumber || "080000000";
  
  const newData: Partial<User> = {
    name: name, 
    phonenumber: phoneNumber, 
    dob: dob,
    lastUpdated: new Date()
  }

  try {
    // Get the user before updating to track changes
    const user = await collections.users?.findOne({ _id: new ObjectId(id) }) as unknown as User;
    
    if (!user) {
      return res.status(404).json({ message: `User ${id} not found` });
    }

    const query = { _id: new ObjectId(id) };
    const result = await collections.users?.updateOne(query, { $set: newData });

    console.table(result)

    if (result) {
      if (result.modifiedCount > 0) {
        // Track what changed for email notification
        const changes: string[] = [];
        if (name && name !== user.name) changes.push(`Name changed from "${user.name}" to "${name}"`);
        if (phonenumber && phonenumber !== user.phonenumber) changes.push(`Phone number updated`);
        if (dob && dob !== user.dob) changes.push(`Date of birth updated`);

        // Send profile update email if there were changes
        if (changes.length > 0) {
          try {
            const updatedUser = { ...user, ...newData };
            const emailSent = await EmailService.sendProfileUpdateEmail(updatedUser, changes);
            if (emailSent) {
              console.log(`Profile update email sent to ${user.email}`);
            } else {
              console.log(`Failed to send profile update email to ${user.email}`);
            }
          } catch (emailError) {
            console.error('Error sending profile update email:', emailError);
            // Don't fail update if email fails
          }
        }

        res.status(200).json({ message: `Updated User` })
      }
      else if (result.matchedCount == 1) {
        res.status(400).json({ message: `User found but no update` });
      }
      else {
        res.status(404).json({ "Message": `${id} not found ` });
      }
    }
    else {
      res.status(400).send(`Unable to update user ${req.params.id}`);
    }
  }
  catch (error) {
    if (error instanceof Error) {
      console.log(`eror with ${error.message}`);
    }
    else {
      console.error(error);
    }
    res.status(400).send(`Unable to update user ${req.params.id}`);
  }
};


export const deleteUser = async (req: Request, res: Response) => {

  let id: string = req.params.id;
  try {
    // Get user before deletion to send email
    const user = await collections.users?.findOne({ _id: new ObjectId(id) }) as unknown as User;
    
    if (!user) {
      return res.status(404).json({ message: `no user found with id ${id}` });
    }

    const query = { _id: new ObjectId(id) };

    // Send account deletion email before deleting
    try {
      const emailSent = await EmailService.sendAccountDeletionEmail(user);
      if (emailSent) {
        console.log(`Account deletion email sent to ${user.email}`);
      } else {
        console.log(`Failed to send account deletion email to ${user.email}`);
      }
    } catch (emailError) {
      console.error('Error sending account deletion email:', emailError);
      // Don't fail deletion if email fails
    }

    const result = await collections.users?.deleteOne(query);

    if (result && result.deletedCount) {
      res.status(204).json({ message: `Successfully removed user with id ${id}` });
    } else if (!result) {
      res.status(400).json({ message: `Failed to remove user with id ${id}` });
    } else if (result.deletedCount == 0) {
      res.status(404).json({ message: `no user found with id ${id}` });
    }
  } catch (error) {
    if (error instanceof Error) {
      console.log(`issue with deleting user ${error.message}`);
    }
    else {
      console.log(`error with ${error}`)
    }

    res.status(400).send(`Unable to delete user`);
  }
};

export const getClients = async (req: Request, res: Response) => {
  // Get users formatted as clients for the frontend
  try {
    if (!collections.users) {
      return res.status(500).json({ error: 'Database not connected' });
    }
    
    const users = await collections.users.find({}).toArray();
    
    // Transform users to client format
    const clients = users.map(user => ({
      _id: user._id,
      name: user.name,
      email: user.email,
      phone: user.phonenumber || "080000000", // Use phonenumber as phone, default to placeholder
      phonenumber: user.phonenumber || "080000000", // Also include phonenumber field
      notes: user.notes || '',
      isBanned: user.isBanned || false,
      roles: user.roles || [], // Include roles, default to empty array
      dateJoined: user.dateJoined || new Date(),
      preferences: user.preferences || {
        favoriteServices: [],
        preferredTimes: [],
        allergies: '',
        specialRequests: ''
      }
    }));
    
    res.json(clients);
  } catch (error) {
    if (error instanceof Error) {
      console.error(`Issue with GET clients: ${error.message}`)
    }
    res.status(500).json({ 'error': 'get clients failed' });
  }
};

export const createClient = async (req: Request, res: Response) => {
  // Create a new client (user) in the database
  console.log('Creating client:', req.body);

  const { name, email, phone, notes, preferences, roles } = req.body;
  
  // Generate a temporary password (in real app, you'd send this via email)
  const tempPassword = 'temp123';
  const saltRounds = 10;
  const hashedPassword = await bcrypt.hash(tempPassword, saltRounds);
  
  // Set default phone number if not provided
  const phoneNumber = phone || "080000000";
  
  const newUser: User = {
    name: name, 
    phonenumber: phoneNumber, // Map phone to phonenumber
    email: email, 
    password: hashedPassword,
    role: "user",
    roles: roles || [], // Default to empty array if no roles provided
    dateJoined: new Date(), 
    lastUpdated: new Date(),
    notes: notes,
    isBanned: false,
    preferences: preferences || {
      favoriteServices: [],
      preferredTimes: [],
      allergies: '',
      specialRequests: ''
    }
  }

  try {
    const result = await collections.users?.insertOne(newUser)

    if (result) {
      // Return client format (without password)
      const client = {
        _id: result.insertedId,
        name: newUser.name,
        email: newUser.email,
        phone: newUser.phonenumber,
        notes: newUser.notes,
        isBanned: newUser.isBanned,
        roles: newUser.roles || [], // Include roles in response
        dateJoined: newUser.dateJoined,
        preferences: newUser.preferences
      };
      
      res.status(201).json({ message: `Created a new client with id ${result.insertedId}`, client });
    }
    else {
      res.status(500).send("Failed to create a new client.");
    }
  }
  catch (error) {
    if (error instanceof Error) {
      console.log(`issue with inserting client ${error.message}`);
    }
    else {
      console.log(`error with ${error}`)
    }
    res.status(500).json({ error: "Failed to create client" });
  }
};

export const updateClient = async (req: Request, res: Response) => {
  const id: string = req.params.id;
  const { name, email, phone, notes, preferences, isBanned, roles } = req.body;
  
  // Set default phone number if not provided
  const phoneNumber = phone || "080000000";
  
  const newData: Partial<User> = {
    name: name,
    phonenumber: phoneNumber, // Map phone to phonenumber
    email: email,
    notes: notes,
    isBanned: isBanned,
    roles: roles, // Include roles in update
    preferences: preferences,
    lastUpdated: new Date()
  }

  try {
    const query = { _id: new ObjectId(id) };
    const result = await collections.users?.updateOne(query, { $set: newData });

    if (result) {
      if (result.modifiedCount > 0) {
        res.status(200).json({ message: `Updated Client` })
      }
      else if (result.matchedCount == 1) {
        res.status(400).json({ message: `Client found but no update` });
      }
      else {
        res.status(404).json({ "Message": `${id} not found ` });
      }
    }
    else {
      res.status(400).send(`Unable to update client ${req.params.id}`);
    }
  }
  catch (error) {
    if (error instanceof Error) {
      console.log(`error with updating client ${error.message}`);
    }
    else {
      console.error(error);
    }
    res.status(400).send(`Unable to update client ${req.params.id}`);
  }
};

export const deleteClient = async (req: Request, res: Response) => {
  const id: string = req.params.id;
  
  console.log('=== DELETE CLIENT DEBUG ===');
  console.log('Client ID to delete:', id);
  
  // Validate ObjectId format
  if (!ObjectId.isValid(id)) {
    console.error('Invalid ObjectId format:', id);
    return res.status(400).json({ error: 'Invalid client ID format' });
  }
  
  try {
    if (!collections.users) {
      console.error('Database not connected');
      return res.status(500).json({ error: 'Database not connected' });
    }
    
    const query = { _id: new ObjectId(id) };
    console.log('Query:', query);

    const result = await collections.users.deleteOne(query);
    console.log('Delete result:', result);

    if (result && result.deletedCount > 0) {
      console.log('‚úÖ Client deleted successfully');
      return res.status(200).json({ 
        message: `Successfully removed client with id ${id}`,
        deletedCount: result.deletedCount
      });
    } else if (result.deletedCount === 0) {
      console.log('‚ùå No client found with id:', id);
      return res.status(404).json({ error: `No client found with id ${id}` });
    } else {
      console.log('‚ùå Delete operation failed');
      return res.status(500).json({ error: 'Failed to delete client' });
    }
  } catch (error) {
    console.error('‚ùå Error deleting client:', error);
    
    if (error instanceof Error) {
      console.error('Error message:', error.message);
      console.error('Error stack:', error.stack);
      
      // Provide more specific error messages
      if (error.message.includes('ObjectId')) {
        return res.status(400).json({ error: 'Invalid client ID format', details: error.message });
      }
      return res.status(500).json({ error: 'Failed to delete client', details: error.message });
    }
    
    return res.status(500).json({ error: 'Failed to delete client' });
  }
};

// Request password reset
export const requestPasswordReset = async (req: Request, res: Response) => {
  try {
    const { email } = req.body;
    
    if (!email) {
      return res.status(400).json({ error: "Email is required" });
    }

    const user = await collections.users?.findOne({ email: email }) as unknown as User;
    
    if (!user) {
      // Don't reveal if email exists or not for security
      return res.status(200).json({ 
        message: "If an account with that email exists, a password reset link has been sent." 
      });
    }

    // Generate reset token
    const resetToken = crypto.randomBytes(32).toString('hex');
    const resetTokenExpiry = new Date(Date.now() + 3600000); // 1 hour from now

    // Store reset token in user document (you might want to create a separate collection for this)
    await collections.users?.updateOne(
      { _id: user._id },
      { 
        $set: { 
          resetToken: resetToken,
          resetTokenExpiry: resetTokenExpiry
        }
      }
    );

    // Send password reset email
    try {
      const emailSent = await EmailService.sendPasswordResetEmail(user, resetToken);
      if (emailSent) {
        console.log(`Password reset email sent to ${user.email}`);
      } else {
        console.log(`Failed to send password reset email to ${user.email}`);
      }
    } catch (emailError) {
      console.error('Error sending password reset email:', emailError);
      return res.status(500).json({ error: "Failed to send password reset email" });
    }

    res.status(200).json({ 
      message: "If an account with that email exists, a password reset link has been sent." 
    });

  } catch (error) {
    console.error('Error requesting password reset:', error);
    res.status(500).json({ error: "Failed to process password reset request" });
  }
};

// Reset password with token
export const resetPassword = async (req: Request, res: Response) => {
  try {
    const { token, newPassword } = req.body;
    
    if (!token || !newPassword) {
      return res.status(400).json({ error: "Token and new password are required" });
    }

    if (newPassword.length < 8) {
      return res.status(400).json({ error: "Password must be at least 8 characters long" });
    }

    // Find user with valid reset token
    const user = await collections.users?.findOne({ 
      resetToken: token,
      resetTokenExpiry: { $gt: new Date() }
    }) as unknown as User;

    if (!user) {
      return res.status(400).json({ error: "Invalid or expired reset token" });
    }

    // Hash new password
    const saltRounds = 10;
    const hashedPassword = await bcrypt.hash(newPassword, saltRounds);

    // Update password and clear reset token
    await collections.users?.updateOne(
      { _id: user._id },
      { 
        $set: { 
          password: hashedPassword,
          lastUpdated: new Date()
        },
        $unset: {
          resetToken: "",
          resetTokenExpiry: ""
        }
      }
    );

    res.status(200).json({ message: "Password reset successfully" });

  } catch (error) {
    console.error('Error resetting password:', error);
    res.status(500).json({ error: "Failed to reset password" });
  }
};

// Update password (for logged-in users)
// Cleanup all users except user@example.com (admin only)
export const cleanupUsers = async (req: Request, res: Response) => {
  try {
    console.log('=== CLEANUP USERS DEBUG ===');
    
    // Find all users except user@example.com
    const usersToDelete = await collections.users?.find({ 
      email: { $ne: 'user@example.com' } 
    }).toArray();
    
    console.log(`Found ${usersToDelete?.length || 0} users to delete:`);
    usersToDelete?.forEach(user => {
      console.log(`- ${user.name} (${user.email})`);
    });
    
    if (usersToDelete && usersToDelete.length > 0) {
      // Delete all users except user@example.com
      const result = await collections.users?.deleteMany({ 
        email: { $ne: 'user@example.com' } 
      });
      
      console.log(`‚úÖ Deleted ${result?.deletedCount || 0} users successfully!`);
      
      res.status(200).json({ 
        message: `Successfully deleted ${result?.deletedCount || 0} users`,
        deletedCount: result?.deletedCount || 0
      });
    } else {
      console.log('‚úÖ No users to delete (only user@example.com exists)');
      res.status(200).json({ 
        message: 'No users to delete (only user@example.com exists)',
        deletedCount: 0
      });
    }
    
    // Show remaining users
    const remainingUsers = await collections.users?.find({}).toArray();
    console.log(`üìã Remaining users (${remainingUsers?.length || 0}):`);
    remainingUsers?.forEach(user => {
      console.log(`- ${user.name} (${user.email}) - Phone: ${user.phonenumber}`);
    });
    
  } catch (error) {
    console.error('Error cleaning up users:', error);
    res.status(500).json({ error: 'Failed to cleanup users' });
  }
};

export const updatePassword = async (req: Request, res: Response) => {
  try {
    const { currentPassword, newPassword } = req.body;
    const userId = req.params.id;
    
    if (!currentPassword || !newPassword) {
      return res.status(400).json({ error: "Current password and new password are required" });
    }

    if (newPassword.length < 8) {
      return res.status(400).json({ error: "New password must be at least 8 characters long" });
    }

    if (!ObjectId.isValid(userId)) {
      return res.status(400).json({ error: "Invalid user ID" });
    }

    // Find user
    const user = await collections.users?.findOne({ _id: new ObjectId(userId) }) as unknown as User;

    if (!user) {
      return res.status(404).json({ error: "User not found" });
    }

    // Verify current password
    const isCurrentPasswordValid = await bcrypt.compare(currentPassword, user.password);
    
    if (!isCurrentPasswordValid) {
      return res.status(401).json({ error: "Current password is incorrect" });
    }

    // Hash new password
    const saltRounds = 10;
    const hashedPassword = await bcrypt.hash(newPassword, saltRounds);

    // Update password
    await collections.users?.updateOne(
      { _id: user._id },
      { 
        $set: { 
          password: hashedPassword,
          lastUpdated: new Date()
        }
      }
    );

    // Send password update email
    try {
      const emailSent = await EmailService.sendPasswordUpdatedEmail(user);
      if (emailSent) {
        console.log(`Password update email sent to ${user.email}`);
      } else {
        console.log(`Failed to send password update email to ${user.email}`);
      }
    } catch (emailError) {
      console.error('Error sending password update email:', emailError);
      // Don't fail password update if email fails
    }

    res.status(200).json({ message: "Password updated successfully" });

  } catch (error) {
    console.error('Error updating password:', error);
    res.status(500).json({ error: "Failed to update password" });
  }
};
